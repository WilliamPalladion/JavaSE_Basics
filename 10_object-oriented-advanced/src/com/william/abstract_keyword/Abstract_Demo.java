package com.william.abstract_keyword;

public class Abstract_Demo {
    public static void main(String[] args) {
        // 抽象类/方法: abstract修饰的类/成员方法
        /*
        修饰符 abstract class Name{
            修饰符 abstract 返回值类型 方法名称(形参列表);
        }
        */
        Dog d  = new Dog();
        d.run();

        // 注意事项：
        // 1）抽象方法只有方法签名，不能声明方法体；
        // 2）一个类中如果定义了抽象方法，这个类必须声明成抽象类，否则报错
        // 3）类有的成员(成员变量、方法、构造器)，抽象类都具备
        // 4）抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类
        // 5）抽象类的子类一定要完成父类的所有抽象方法重写，否则这个类也必须定义成抽象类

        // 抽象类最重要的特征：得到了抽象方法，失去了创建对象的能力
        // Animal a = new Animal(); 报错

        // 为什么？我们可以反证：如果可以创建对象，那么 a.run() 方法该如何运行？ 这个抽象方法连方法体都没有
        // 哪怕这个抽象类没有抽象方法也不行！因为Java的语法非常严谨且一刀切，如果你后期自己添加了一个抽象方法该如何？

        // final 和 abstract 是什么关系：互斥关系 (一个不能被继承，一个一定要继承)
        // abstract定义的抽象类作为模板被子类继承，final定义的类不能被继承
        // 抽象方法定义通用功能让子类重写，final定义的方法子类不能重写
    }
}
