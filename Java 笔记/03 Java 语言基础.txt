03 Java 语言基础

# 目标知识：类型转换 + 运算符 + 调用Java包


3.1 类型转换

3.1.1 自动类型转换

# 类型范围小的变量，可以直接赋值给 类型范围大 的变量
byte a = 12;
int b = a;
System.out.println(a);

# 底层原理：
a: 00001100 (1 byte = 8 bit, 首位的0代表正数)
b: 00000000 00000000 00000000 00001100 (4字节32位，直接在前方补位)

# 自动类型转换的其他形式：
byte -> short -> int -> long -> float -> double (当然可以跳跃往前)
char -> int (char 2字节，字符底层还是二进制)


3.1.2 表达式的自动类型转换

# 在表达式中，小范围类型的变量会自动转换成当前较大范围的类型再运算
# byte/short/char -> int -> long -> float -> double

# Note: 1) 表达式的最终结果类型由表达式中的最高类型决定
        2) 表达式中，byte/short/char 是直接转换成int类型参与运算的



3.1.3 强制类型转换

int a = 20;
byte b = a;
# 类型范围大的数据或变量，不能直接赋值给类型范围小的变量，否则会报错

# 存在强制类型转换的方法如下：
DataType var2 = (DataType) var1/data

int a = 20;
byte b = (byte) a;

# 底层原理：
a: 0000000 00000000 00000000 00010100
                          b: 00010100


int i = 1500;
byte j = (byte) i;

i: 00000000 00000000 00000101 11011100
                           j: 11011100 (首位的1代表是个复数)
						   
# 为何是-36会在高级篇的补码讲述

# 浮点型强转为整形，直接丢掉小数部分，保留整数部分返回
double score = 99.5;
int it = (int) score;
System.out.println(it); // 99





3.2 运算符

3.2.1 算数运算符

+ - * 
/: 注意在Java中两个整数相除结果还是 整数 (最高类型)
%: 取余

# 如果一定需要准确的带小数的结果，可以 * 1.0 (注意 * 1.0 要放在前面！)

# '+' 做连接符号
# 能算则算，不能算就连起来
int i = 5;
System.out.println("abc" + 'i'); // abci
System.out.println("abc" + i); // abc5
System.out.println("abc" + 5 + 'i'); // abc5i
System.out.println(15 + "abc" + 15); // 15abc15
        
System.out.println(i + 'a'); // 5 + 97 = 102, 注意此时 'a' 在ASCII编码表为97，所以可以算
System.out.println(i + "" + 'a'); // i + "" = "5", 5a
System.out.println(i + 'a' + " william "); // 102 william
System.out.println("william" + i + 'a'); // william5a
System.out.println("william" + (i + 'a')); // 括号有优先级，所以是 william102



3.2.2 自增自减运算符 

++: 自增，变量自身的值加1
--: 自减，变量自身的值减1

# ++/-- 既可以放在变量前，也可放在变量后
# ++/-- 只能操作变量，不能操作字面量 (e.g. 2++ 是不行的)

# ++/-- 若不是单独使用（如在表达式中，或同时有其他操作），放在变量前后有明显区别
# 放在变量前：先对变量+1/-1, 再进行计算
int a = 10;
int rs = ++a; // rs = a = 11

# 放在变量后：先进行运算, 再对变量+1/-1
int a = 10;
int rs = a++ + 5; // rs = 15, a = 11

# Case:
int m = 3;
int n = 5;
int rs2 = m++ + ++m - --n + n-- - m-- + ++n + 2;

// 技巧：对每一个变量列一行，同步更新值
// m   3 4 5 4
// n   5 4 3 4
// rs2 3 + 5 - 4 + 4 - 5 + 4 + 2
System.out.println(rs2); // 9
System.out.println(m); // 4
System.out.println(n); // 4



3.2.3 赋值运算符

# 基本赋值运算符 "="

# 扩展赋值运算符：+=, -=, *=, /=, %=
# 隐含了强制类型转换

a += b：a = (a的数据类型) (a + b); # 将 a+b 的值赋给a

# 这种赋值方法能够更简化一些特殊的情况
byte i = 10;
byte j = 20; 
// i = (byte) (i + j); 这个时候一定需要强制转换了，因为这个时候i和j都被当成int来计算
i += j;
System.out.println(i);



3.2.4 关系运算符

# 对数据进行条件判断的符号，最终返回一个比较的布尔结果 (true, false)
# ==, !=, >, >=, <, <=


3.2.5 逻辑运算符

# 把多个条件的布尔结果放在一起运算，最终返回一个布尔结果

# &(与), |(或), !(非), ^(异或)

&：都是true才是true
|: 有一个true就是true
!: 取反
^: 两个条件真假相反为true

# 短路逻辑运算符 (效率更高)

&&: 短路与，结果与&一样，如果左边是false，则右边不执行
||: 短路或，结果与|一样，如果左边是true，则右边不执行



3.2.6 三元运算符

# 条件表达式 ? value1 : value2
# 流程：首先计算条件表达式的值，为true返回value1，为false返回value2

double score = 98;
String rs = score >= 60 ? "合格" : "不合格";



3.2.7 运算符优先级

优先级记忆方法：单目乘除为关系，逻辑三目后赋值

单目运算符:一次作用一个变量的运算符，又叫一元运算符
单目：单目运算符+ –(正负数) ，++ –，！（逻辑非），~（按位取反）
乘除：算数运算符：* / % + - 
为：位运算符：~（按位取反）<<(左移) >>(右移)，^（也可以位运算，二进制异或）
关系：关系运算符：> < >= <= == !=
逻辑：逻辑运算符（除！）&& || & | ^
三目：条件运算符A > B ? X : Y
后：无意义，仅仅为了凑字数
赋值：= += -= *= /= %= |= &= ^= 

()
! -(负) ++ --
* / %
+ -
<< >> >>>
< <= > >= instanceof
== !=
&
^
|
&&
||
?:
= += -= *= /= %= %=




3.2.8 Case: 键盘录入交互

JDK -> JRE (JVM + 程序(API))

API: Application Programming Interface (应用程序编程接口)

# 可以直接调用Java写好的程序(功能代码)
