07 面向对象

# 面向：拿、找， 对象：东西/工具 -> 面向对象编程：寻找借用工具来编程
# 面向对象的好处：借用工具编程，符合人类思维习惯，编程更简单、更容易理解
# 学习自己设计对象并使用 -> 面向对象的语法


7.1 设计类和对象

# 先设计类，才能获得对象 (e.g. 设计图 -> 具体物品)

类：是对象共同特征的描述 (设计图)
对象(实例)：真实存在的具体实例

// 创建类
public class Car{
	...
}

new Car() // 创建对象
new Car() // 创建第二个对象
...

# 定义类

public class 类名{
	1. 成员变量 (属性，一般是名词)
	2. 成员方法 (行为，一般是动词)
	3. 构造器
	4. 代码块
	5. 内部类
}

public class Car{
	// 成员变量 (属性)
	String name;
	double price;
	
	// 成员方法 (行为)
	public void start(){
	}
	public void run(){
	}
}

# 得到类的对象

类名 对象名 = new 类名

Car c = new Car();
c.name;
c.price;

# 把定义的类在窗口并列展开观看
IDEA: 在类文件右击并点击 Split and move right


# 注意事项
1）一个Java文件中可以定义多个class类，但只能一个类是public修饰
   且public修饰的类名必须成为代码文件名；
  
2）成员变量的完整定义格式是：修饰符 数据类型(引用类型) 变量名 = 初始值;
   一般无需指定初始化值，存在默认值 (0, 0.0, false, null)
   
   


7.2 对象在内存中的运行机制

# 对象在堆内存中开辟一块内存空间，
# 放成员变量和成员方法的引用地址，通过地址指向方法区的方法，把地址赋值给变量
Car c1 = new Car(); // c1: 119d7047

c1.run();
# 根据c1变量存储的地址访问堆内存中指向的对象，根据对象存储的成员方法引用地址，
# 访问方法区的run()方法，并把方法加载到栈内存中运行，由于run()方法是c1变量调用的
# 它使用的信息都会是c1所指向的对象


# 两个变量指向同一个对象

两个变量存储同一个对象的地址

# 垃圾回收

当堆内存中的对象，没有被任何变量引用(指向)时，就会被判定为内存中的 “垃圾”
s1 = null;
s2 = null;
Java存在自动垃圾回收器，会定期进行清理




7.3 构造器

# 学习构造器的目的：
1）真正知道对象具体是通过调用什么代码得到的
2）掌握为对象赋值的其他简便写法

# 构造器：定义在类中可以用于初始化一个类的对象，并返回对象的地址
e.g. Car c = new Car();  # Car() 指的就是一个构造器

修饰符 类名(形参列表){
	...
}

public class Car{
	...
	// 无参数构造器
	public Car(){
		...
	}
	
	// 有参数构造器
	public Car(String n, double p){
		...
	}
}

# 无参数构造器：(默认存在) 初始化对象时，成员变量均采用默认值
  有参数构造器：初始化对象时可以接收参数为对象进行赋值

# 调用构造器得到对象：class var = new Constructor;

Car c = new Car();
Car c1 = new Car("BMW", 39.8);

# Note:

1）任何类构造出来，默认就自带了无参数构造器，写不写无所谓
2）一旦定义了有参数构造器，那么无参数构造器就没有了，想要用无参数构造器，必须要手写一个




7.4 this 关键字

# this 可以出现在构造器/方法中，代表当前对象的地址

public class Car{
	public Car(){
		System.out.println("this在构造器中：" + this);
	}

	public void run(){
		System.out.println("this在方法中：" + this);
	}
}

# this 代表当前对象的地址

public class Test{
	public static void main(String[] args){
		Car c = new Car();
		c.run(); // 此时 this 就是变量c指向的对象的地址
		System.out.println(c);
	}
}



7.5 封装

# 面向对象三大特征：封装，继承，多态

# 封装：告诉我们如何正确设计对象的属性和方法
# 封装的原则：对象代表什么，就封装对应的数据，并提供数据对应的行为(方法)

e.g. 人画一个圆 -> 对象：人 (People) & 圆 (Circle)， 行为：画 (draw)

public class People{}

public class Circle{}

public void draw(){}

# draw 方法应该封装在哪里？ -> 应该在 圆(Circle)类中
public class Circle{
	double radius; // 对应数据：半径
	
	// 对应的行为；画圆
	public void draw(){
		System.out.println("按照半径" + radius + "画圆");
	}
}

# 人画圆：其实是圆自己画的，或者说是人调用了圆的draw()方法
# e.g. 人关门：门自己关的

# 好处：Sun公司设计Java时定义了各种各样的对象，遵循了封装的思想
        有什么需求，就调用对应的对象，给它需要的数据，调用对应的方法就行，简化编程
		
		e.g. String 字符串对象 -> 方法 char(), int(), ...
			 Socket 网络连接对象
			 
			 
			 
# 如何更好地进行封装：

一般建议对成员变量使用 private 关键字进行修饰 (private修饰的成员只能在当前类中访问)
同时为每个成员变量提供配套的 public 修饰的 getter/setter 方法暴露其取值和赋值




7.6  JavaBean

# JavaBean: 亦称实体类，其对象可以用于在程序中封装数据
# 实体类：定义的在现实生活中有对应存在个体的类，称为实体类 (Student, Car, etc.)

标准JavaBean的书写要求：
1）成员变量要用 private 修饰；
2）提供成员变量对应成套的 setXxx()/getXxx() 方法；
3）必须提供一个无参构造器；有参构造器可写可不写；

# IDEA： 右击选中 Generate -> 选 Getter and Setter 选中成员变量

# 一般不加判断是因为送到后台的数据一般就是合规的



# 成员变量和局部变量的区别

区别              成员变量              局部变量
类中位置不同      类中，方法外          常见于方法中
初始化值不同	  有默认值，无需初始化  没有默认值，使用前要赋值
内存位置不同	  堆内存(对象在堆内存)	栈内存(方法在栈内存)
生命周期不同	  随着对象创建而存在，  随着方法调用而存在，
				  对象消失而消失        方法运行结束而消失
作用域不同		  很难限定，            在所属的大括号中
				  外部方法也可访问				