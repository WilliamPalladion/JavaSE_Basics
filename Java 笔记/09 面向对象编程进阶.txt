09  面向对象编程进阶

# Contents:
# static 关键字(表示共享信息)、设计模式(单例: 一个类只产生一个对象)、继承 (优化重复代码冗余)、语法、接口、多态、内部类、常用API



9.1  static 关键字

# static: 静态，可以修饰成员变量和成员方法
# static 修饰成员变量表示该成员变量只在内存中存储一份(属于类)，可以被共享访问、修改

e.g. 当前聊天室人数：161人 (所有人都能看到，但只需要一份)

public class User{
	// 静态成员变量
	public static int onlineNumber = 161;
}

# 访问静态成员变量
类名.静态成员变量 (推荐)
对象.静态成员变量


# 成员变量分为两类：
1）静态成员变量 (static修饰，属于类，内存中加载一次): 常表示被共享的信息，可以被共享访问 (e.g. 在线人数)

2）实例成员变量 (无 static 修饰，存在于每个对象中): 常表示姓名、年龄等属于每个对象的信息
对象.实例成员变量


# 内存原理：
在方法区加载类的同时，会在堆内存生成类的静态变量区 (与类同步加载)


# 成员方法分为两类：
1）静态成员方法 (static修饰，归属于类)：可以共享访问，建议用类名访问

2）实例成员方法 (无static修饰，归属于对象): 只能用对象访问


# 使用场景：

表示对象自己的行为的，且方法中需要访问实例成员的，则方法必须申明为实例方法；
如果该方法是以执行一个共用功能为目的，则可以申明为静态方法；


# 内存原理：
方法区加载类时，会立即加载static静态方法 (main, getMax)，但study方法没有被加载
对象被创建后，才会存储实例方法的地址，实例方法在方法区被加载出来


# static 关键字注意事项：
1）静态方法只能访问静态的成员，不能直接访问实例成员；
2）实例方法可以访问静态的成员，也可以访问实例成员；
3）静态方法中不可以出现this关键字





9.2 static 工具类

# 工具类：类中都是一些静态方法，每个方法都以完成一个共用的功能为目的，这个类用来给系统开发人员共同使用

e.g. 企业管理系统中，一个系统的很多业务都需要验证码来防刷新，验证码这个共用的功能就可以如此实现

# 问题：同一个功能多处开发，会出现代码重复度过高
# 工具类的好处：调用方便，提高代码的复用

# 工具类不用实例方法：实例方法需要创建对象调用，此时用对象仅仅为了使用方法会浪费内存

# 工具类定义时的要求：
由于都是静态方法，直接用类名访问即可，所以工具类无需创建对象，建议直接将工具类的构造器私有 
private className(){
}



9.3  代码块

# 代码块是类的5大成分之一 (成员变量，构造器，方法，代码块，内部类)，定义在类中方法外
# Java类下 {} 内的代码被称为代码块 (单独的一个{}，与方法下属的{}进行区分!)

# 分类：

1） 静态代码块: static{}
# 通过static关键字修饰，随着类的加载而加载，且自动触发，只执行一次
# 使用场景：在类加载时做一些静态数据初始化的操作，方便后续使用

2）构造(/实例)代码块：{}
# 每次创建对象，调用构造器时，都会执行该代码块中的代码，且在构造器执行前执行
# 使用场景：初始化实例资源




9.4  单例设计模式

# 设计模式 (Design Pattern): 开发过程中一个问题有n种解法，但肯定有一种最优解，这个最优解被人总结出来称为设计模式

# 设计模式有20多种，对用20多种软件开发中会遇到的问题
# 主要关注：1）这种模式是解决什么问题；
            2）遇到这种问题，设计模式是怎么解决的；
			
# 单例模式：保证系统中，应用该模式的这个类永远只有一个实例 (i.e. 一个类永远只能创建一个对象)
e.g. 任务管理器一个就够，可以节省内存空间

# 单例的实现方式很多：饿汉单例模式、懒汉单例模式、...

# 饿汉单例模式：在用类获取对象时，对象已经提前为你创建好了
设计步骤：1）定义类，将构造器私有 private className(){}
          2) 定义一个静态变量存储一个对象 public static className instance = new className();


# 懒汉单例模式：在真正需要对象时，才去创建一个对象 (延迟加载对象)
设计步骤：1）定义类，将构造器私有 private className(){}
          2) 定义一个静态变量存储一个对象 public static className instance; (没有new一个对象！)
		  3) 提供一个返回单例对象的方法 public static className getInstance(){
											...
											return ...;
										}
										


9.5   继承

# Java中提供一个关键字 extends, 可以让两个类之间建立起父子关系
# 当子类继承父类后，就可以直接使用父类的属性和方法：提高代码的复用性，减少代码的冗余，增强类的功能扩展性

e.g. public class Student extends People {}

# Student 称为子类(派生类)；People 称为父类 (基类/超类)


# 继承设计规范：子类们相同特征(共性属性/方法)放在父类中定义，子类独有的属性和行为应该定义在子类自己里面

Case: 教育管理系统 (学生、老师)

Student: 名称、年龄、所在班级、查看课表、填写听课反馈
Teacher: 名称、年龄、部门名称、查看课表、发布问题

==> 定义角色类作为父类：名称、年龄、查看课表


# 内存原理：
生成对象时，会产生两个空间：父类空间 (super) + 子类空间 (this)


# 继承的特点：
1）子类可以继承父类的属性和行为，但不能继承父类的构造器；

2）Java是单继承模式：一个类只能继承一个直接父类；(可以反证为什么不支持：一旦两个父类中有同名的方法，又输出不同的结果，就会冲突)

3）Java不支持多继承，但支持多层继承；(这时候如果有同名方法，优先选择使用最直系的父类 (A -> B -> C，C优先选用B类的同名方法))

4）Java中所有类都是Object类的子类

# 子类是否可以继承父类的私有成员? 可以，但不能直接访问！(有争议，有些材料认为是不能继承，但子类中也有父类空间，只是不能直接访问)

# 子类是否可以继承父类的静态成员? 这只能说是共享，并非继承 (有争议)

# Java中所有类，要么直接继承Object，要么默认继承Object，要么间接继承了Object，Object是祖宗类


# 继承后：成员变量/方法的访问特点：

1）在子类方法中访问成员满足：就近原则 => 子类局部范围找 -> 子类成员范围找 -> 父类成员范围找，若没有就报错

this -> 指定调用当前对象的成员变量/方法
super -> 指定调用父类的成员变量/方法


# 方法重写：
在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法是重写的方法

# 应用场景：当子类需要父类的功能，但父类的该功能不能完全满足自己的需求时，子类可以重写父类中的方法

@Override 重写注解：放在重写后的方法上，作为重写是否正确的校验注解

# 方法重写的注意事项：
1）重写方法的名称、形参列表必须和被重写方法的名称和参数列表一致
2）私有方法不能被重写 (不会报错但不会认为这个是重写方法，而是一个新方法)
3）子类重写父类方法时，访问权限必须大于或等于父类 (缺省(本类/本包的子类) < protected (本类/本包/其他包的子类) < public)
   # 实际开发中建议和父类的权限一致
4）子类不能重写父类的静态方法



# 继承后子类构造器的特点：
子类中所有的构造器都会默认先访问父类中无参的构造器，再执行自己
因为子类在初始化时可能会用到父类中的数据，如果父类没有初始化，子类将无法使用父类的数据

# 在代码层面，其实子类构造器的第一行语句默认都是 super(), 不写也默认存在



# 继承后子类构造器访问父类 有参构造器：

# super 调用父类有参数构造器：直接初始化继承自父类的数据

# 如果父类中没有无参数构造器，只有有参构造器：会报错，因为子类默认调用父类无参构造器


# this/super 详情总结：

this: 代表本类对象的引用
super: 代表父类存储空间的标识

# 我们只有以下用法没有接触过：
# this(...): 访问本类的构造器

# 注意事项：
1）子类通过 this(...) 去调用本类构造器，本类其他构造器会通过 super 去调用父类的构造器，最终还是会调用父类构造器
2）this(...) 和 super(...) 都只能放在构造器的第一行，所以二者不能共存在同一个构造器中

# 为什么this(...)也要在第一行，因为如果不先立即通过兄弟构造初始化父类，就不能初始化子类的构造器




9.6   语法

# 包、权限修饰符、final、常量、枚举

9.6.1  包

# 包是用来分门别类地管理各种不同类的，类似文件夹；建包有利于程序的管理和维护

# 建包的语法： package Name;
# 建包必须在第一行，IDEA帮我们自动创建

# 导包：import packName.className
相同包下的类可以直接访问，不同包下的类必须导包

# 如果类中要使用不同包下的相同的类名，默认只能导入一个类的包，另一个类要用全名访问



9.6.2  权限修饰符 (modifier)

# 权限修饰符：用来控制一个成员能够被访问的范围
# 可以修饰：成员变量，方法，构造器，内部类

分类&范围(由小到大)：private < 缺省 < protected < public

private: 同一个类中
缺省: 同一个类中，同一个包中其他类 (包访问权限)
protected: 同一个类中，同一个包中其他类，不同包下的子类(记得要创建子类对象！)
public: 同一个类中，同一个包中其他类，不同包下的子类，不同包下的无关类

# 自己定义成员一般满足以下需求：
1）成员变量一般私有
2）方法一般公开
3）如果该成员只希望本类访问，使用private修饰
4）如果该成员只希望本类，同一包下的其他类和子类访问，使用protected修饰



9.6.3   final 关键字

# final 表最终，可以修饰 (类，方法，变量):
1) 修饰类：表明该类是最终类，不能被继承；
2）修饰方法：表明该方法是最终方法，不能被重写；
3）修饰变量：表明该变量第一次赋值后，不能再次被赋值 (能且仅能被赋值一次)

# 工具类可以用final来修饰：工具类只需要使用，不要继承
public final class xxx{}

# final 注意事项：
1）final 修饰基本类型：变量存储的 数据值 不变；
2）final 修饰引用类型：变量存储的 地址值 不变，但是地址指向的对象内容是可以发生变化的



9.6.4   常量

# 常量：用 public static final 修饰的成员变量，必须有初始化值，而且执行过程中其值不能被改变

# 作用和好处：常量可以用于做系统的配置信息，方便程序的维护，提高可读性

常量命名规范：英文全部大写，多个单词下划线连接 
public static final String SCHOOL_NAME = "Wiliiam";

# 常量的执行原理：
在编译阶段会进行 "宏替换"，把使用常量的地方全部替换成真实的字面量 (就不需要再读取变量来获取值了)；
这样的好处是让使用常量的程序的执行性能与直接使用字面量一样


# 常量用来做信息标志和分类

Case: 开发游戏需要接收用户输入的4个方向的信号 (上下左右)



9.6.5  枚举

# 枚举是一种特殊的类，它有有限个不同的实例对象，主要是为了做信息的标志与分类

修饰符 enum 枚举名称{
	第一行罗列枚举类实例的名称
}

public enum Season{
	SPRING, SUMMER, AUTUMN, WINTER; // 当前这个枚举类的所有对象 (也称多例模式)
}

javac Season.java
javap Season.class // 反编译命令

public final class Season extends java.lang.Enum<Season> {
    public static final Season SPRING = new Season();
    public static final Season SUMMER = new Season();
    public static final Season AUTUMN = new Season();
    public static final Season WINTER = new Season();
    public static Season[] values();
    public static Season valueOf(java.lang.String);
}

枚举类的特征：1) 枚举类都继承了枚举类型 java.lang.Enum
              2) 枚举类都是final类，不可以被继承
              3) 枚举类的构造器都是私有的，枚举类对外不能创建对象
              4) 枚举类的第一行默认罗列枚举对象的名称，且都是常量
			  

Case: 开发游戏需要接收用户输入的4个方向的信号 (上下左右)

# 之前选择用常量做信息标志和分类：虽然可以实现可读性，但入参值不受约束，代码相对不够严谨

# 枚举做信息标志和分类：代码可读性好，入参约束严谨，代码优雅，是最好的信息分类技术！

# 如果是为了表示具体的数据值，还是使用常量；如果只是需要分类，建议用枚举



9.7  抽象类

# 抽象类/方法: abstract修饰的类/成员方法

修饰符 abstract class Name{
	修饰符 abstract 返回值类型 方法名称(形参列表);
}

// e.g. 我们想把Animal定义为父类，让其他具体的动物类来继承，
// 比如大家都会跑，都有run()方法，但每个动物的跑法可能都不一样，所以我们不把方法完全写出来，而是抽象化，交给具体的子类去实现
// 因此我们可以把抽象类/方法理解为一种 “填空”，只定了大体的方向，但具体细节需要子类继续填充
public abstract class Animal {
    public abstract void run(); // 有了抽象方法，就要把类声明成抽象类
}

# 注意事项：
1）抽象方法只有方法签名，不能声明方法体；
2）一个类中如果定义了抽象方法，这个类必须声明成抽象类，否则报错
3）类有的成员(成员变量、方法、构造器)，抽象类都具备
4）抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类
5）抽象类的子类一定要完成父类的所有抽象方法重写，否则这个类也必须定义成抽象类
6）abstarct不能修饰变量、代码块、构造器

# 抽象类最重要的特征：得到了抽象方法，失去了创建对象的能力
// Animal a = new Animal(); 报错

为什么？我们可以反证：如果可以创建对象，那么 a.run() 方法该如何运行？ 这个抽象方法连方法体都没有
哪怕这个抽象类没有抽象方法也不行！因为Java的语法非常严谨且一刀切，如果你后期自己添加了一个抽象方法该如何？

# final 和 abstract 是什么关系：互斥关系


# 模板方法模式：

场景：当系统中出现一个功能被多处在开发，而该功能中大部分代码一样，只有其中部分可能不同时；

实现步骤：
1）将功能定义成一个所谓的模板方法，放在抽象类中，模板方法中只定义通用且能确定的代码；
2）模板方法中不能决定的功能定义成抽象方法让具体子类去实现
3）模板方法建议用final来修饰，防止被重写失去模板的意义

Case: 模板方法模式

现在有两类学生：中学生和小学生都要写《我的爸爸》这篇作文；
要求每种类型的学生，标题第一段和最后一段，内容必须一样，正文部分自由发挥



9.8  接口

# 接口 (interface)：体现一种规范，规范一定是公开的 (public)
// 由于接口提心规范思想，所以 public ... 可以省略不写

# 老版接口 (JDK 8 前)
public interface 接口名{
	// 常量
	// 抽象方法
}


# 接口的使用：接口是用来被类 实现 (implements) 的，实现接口的类称为 实现类 (可以理解为子类)；

修饰符 class 实现类 implements 接口1, 接口2, 接口3, ... {
}

# 接口可以被类单实现，也可以被类多实现

# 接口与接口之间的多继承关系：

类和类：单继承
类和接口：多实现
接口与接口：多继承，一个接口可以同时继承多个接口

# 合并其他所有接口的功能，然后它的实现类只需要实现一个接口
# 规范合并，整合多个接口为同一个接口，便于子类实现


# JDK 8 后的接口： 允许接口中直接定义带有方法体的方法

e.g. 如果在软件开发完成后，对接口功能进行了丰富，那么此时所有的实现类就要实现这些方法，就会非常麻烦；
     为了在丰富接口功能的同时又不对子类代码进行更改，JDK 8 后允许接口中直接定义带有方法体的方法

1. 默认方法

# 类似实例方法，必须用default修饰 (默认用public修饰)，需要用接口的实现类的对象来调用
default void run(){
    ...
}

2. 静态方法

# 默认用public修饰，必须用static修饰
# 注意：接口的静态方法必须用本身的接口名来调用

static void inAddr(){}


3. 私有方法 (JDK 1.9 开始新增)

# 私有的实例方法；必须用private修饰
# 只能在本类中被其他的默认方法或私有方法访问 (因为它是实例方法) 

private void go(){}



# 接口的注意事项：
1）接口不能创建对象 (接口是更加彻底的抽象)；

2）一个类实现多个接口，多个接口中有同样的静态方法不冲突；

3）一个类继承了父类，又实现了接口，父类中和接口中有同名方法，默认用父类的；

4）一个类实现了多个接口，多个接口中有同名的默认方法，不冲突，这个类重写该方法即可；

5）一个接口继承多个接口是可以的，但如果多个接口中存在规范冲突则不能多继承






9.9  多态

# 面向对象三大特征之三：多态

# 多态：同类型的对象，执行同一个行为，会表现出不同的行为特征
e.g. 猫和狗都是动物类型，它们都会跑，但它们跑得可能不一样快

# 常见形式：
父类类型 对象名称 = new 子类构造器；
接口 对象名称 = new 子类构造器；

# 多态中成员访问特点：
方法调用：编译看左边，运行看右边；
变量调用：编译看左边，运行看左边；(多态侧重于行为多态)


# 多态的前提：有继承/实现关系；有父类引用指向子类对象；有方法重写

# 优势：

1）在多态形式下，右边对象可以实现解耦合(代码间依赖关系降低)，便于扩展和维护
Animal a = new Dog(); // 如果我们不需要Dog对象，而是要改成Tiger对象
a.run(); // 后续业务行为随对象直接改变，代码无需修改

e.g. 可以类比一辆玩具汽车，如果电池没电了，只要把电池拿出来换了就可以继续工作，其他部件照常

2）定义方法时，使用父类类型作为参数，该方法就可以接收该父类的一切子类对象，体现出多态的扩展性和便利

# 多态的一个问题：多态下不能使用子类的独有功能 (因为编译阶段会报错)



# 多态下引用数据类型的类型转换

1）自动类型转换 (子类 -> 父类)：小到大，子类对象赋值给父类类型的变量指向；

2）强制类型转换 (父类 -> 子类)：大到小，必须强转
子类 对象变量 = (子类) 父类类型的变量
# 作用：可以解决多态的劣势，实现调用子类独有的功能

# 注意：如果转型后的类型和对象真实类型不是同一种类型，那么在转换时就会出现ClassCastException
Animal t = new Tortoise();
Dog d = (Dog) t; // Error: ClassCastException

# Java建议在强转前使用 instanceof 判断当前对象的真实类型，再进行强转
# 判断左边的变量指向的对象的真实类型，是否是右边的类型或者其子类类型，是则返回true；
变量名 instanceof 真实类型;


Case: 多态综合案例
设计一个电脑对象，可以安装两个USB设备：
鼠标：被安装时可以完成接入、调用点击功能、拔出功能；
键盘：被安装时可以完成接入、调用打字功能、拔出功能；

分析：定义一个USB的接口，申明USB设备的规范必须是：可以接入和拔出
      提供两个USB的实现类鼠标和键盘，并分别定义独有功能
	  创建一个电脑对象，创建USB设备对象，安装启动
	  
	  



9.10   内部类

# 内部类：定义在一个类里面的类。内部类可以理解为 (寄生)，外部类可以理解为 (宿主)。

public class People{
	// 内部类
	public class Heart{
	}
}

# 使用场景和作用：
1）当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部结构右只为外部事物服务时，那么可以用内部类来设计；
2）内部类可以方便访问外部类的成员，包括私有的成员；
3）内部类提供了更好的封装性：内部类可以用 private protected 等修饰 (外部类只能用public/缺省修饰)，封装性可以做更多控制


分类：静态内部类、成员内部类 (非静态内部类)、局部内部类、匿名内部类 (重点)

1）静态内部类

# static修饰，属于外部类本身；特点与使用和普通类完全一致，只是位置在类中

// 创建对象：外部类.内部类 对象名 = new 外部类.内部类构造器();
// Outer.Inner instance = new Outer.InnerConstructor();

Notes：
1）静态内部类可以直接访问外部类的静态成员
2）静态内部类不可以直接访问外部类的实例成员：外部类的实例成员必须用外部类对象访问


2）成员内部类

# 无static修饰，属于外部类的对象
# JDK 16 前，成员内部类中不能定义静态成员

// 创建对象：外部类.内部类 对象名 = new 外部类构造器().new 内部类构造器();
// Outer.Inner instance = new Outer().new Inner();

Notes：
1）成员内部类可以直接访问外部类的静态成员
2）成员内部类可以直接访问外部类的实例成员：因为必须先有外部类对象，才有成员内部类对象，所以可以直接访问
3）在成员内部类中访问所在外部类对象：外部类.this


3）局部内部类 (鸡肋，极少用)

# 局部内部类放在方法、代码块、构造器等执行体中；
# 局部内部类的类文件名为：外部类$N内部类.class


4) 匿名内部类

# 本质上是一个没有名字的局部内部类，定义在方法、代码块等中；
# 作用：方便创建子类对象，最终目的是为了简化代码编写
# 会产生class文件：Filename$number.class (e.g. Test$1.class)

# 格式：
new 类/抽象类/接口名() {
	重写方法;
};

# 特点：
1）匿名内部类是一个没有名字的内部类；
2）匿名内部类写出来就创建了一个匿名内部类的对象；
3）匿名内部类的对象类型相当于是当前new的类型的子类类型；

# 开发中不是我们主动去定义匿名类的，而是别人需要我们写或者可以写的时候才会使用；
# 匿名内部类的代码可以实现代码进一步的简化




9.11 常用API

1) Object

# 一个类要么默认继承了Object类，要么间接继承了Object，Object是祖宗类；因此子类都可以直接调用Object类的方法

# 常用方法：

public String toString(): 默认返回当前对象在堆内存中的地址信息 (类的权限名@内存地址)
public Boolean equals(Object o): 默认比较当前对象与另一对象的地址是否相同

# toString():

// 开发中直接输出对象的地址其实毫无意义，我们更希望看到对象的内容数据
// 父类toString()方法存在的意义就是为了被子类重写，以便返回对象的内容信息


# equals():

// 如果只是比较两个对象的地址，完全可以用 == 来替代
// 父类equals()方法存在的意义就是为了被子类重写，以便子类自己来定制比较规则



2） Objects

# Objects类与Object类还是继承关系，从 JDK 1.7 后开始出现
# 官方在进行字符串比较时，没有用对象自己的equals方法，而是用了Objects的equals方法，结果一样但更安全 (null的情况)

public static boolean equals(Object a, Object b) {
    return (a == b) || (a != null && a.equals(b));
}


9.12  包装类

# Java为了实现一切皆对象，为8种基本类型提供了对应的引用类型
# 后面的集合和泛型其实也只能支持包装类型，不支持基本数据类型

基本数据类型	引用数据类型
byte			Byte
short			Short
int				Integer
long 			Long
char			Character
float			Float
double			Double
boolean			Boolean


# 自动装箱：基本类型的数据/变量可以直接赋值给包装类型的变量
  自动拆箱：包装类型的变量可以直接赋值给基本数据类型的变量
 
# 包装类的特有功能：

1）变量的默认值可以是null，容错率更高；
2）可以把基本类型的数据转换成字符串类型：
   toString(), Integer.toString()
3) 可以把字符串类型的数据转换成真实的数据类型：
   Integer.parseInt("字符串类型的整数");
   Double.parseDouble("字符串类型的小数")